"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterConfiguration = void 0;
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const yaml_1 = __importDefault(require("yaml"));
const glob_1 = __importDefault(require("glob"));
const KAPETA_CLUSTER_SERVICE_CONFIG_FILE = 'cluster-service.yml';
const KAPETA_CLUSTER_SERVICE_DEFAULT_PORT = '35100';
const KAPETA_CLUSTER_SERVICE_DEFAULT_HOST = '127.0.0.1'; //Be specific about IPv4
const KAPETA_DIR = process?.env?.KAPETA_HOME ?? path_1.default.join(os_1.default.homedir(), '.kapeta');
const CLUSTER_CONFIG_FILE = path_1.default.join(KAPETA_DIR, KAPETA_CLUSTER_SERVICE_CONFIG_FILE);
const REPOSITORY_DIR = path_1.default.join(KAPETA_DIR, 'repository');
const AUTH_TOKEN_PATH = process?.env?.KAPETA_CREDENTIALS
    ? process.env.KAPETA_CREDENTIALS
    : path_1.default.join(KAPETA_DIR, 'authentication.json');
const PROVIDER_TYPES = [
    'core/block-type',
    'core/block-type-operator',
    'core/resource-type-extension',
    'core/resource-type-internal',
    'core/resource-type-operator',
    'core/language-target',
    'core/deployment-target',
];
class ClusterConfiguration {
    getClusterServicePort() {
        if (process?.env?.KAPETA_LOCAL_CLUSTER_PORT) {
            return process.env.KAPETA_LOCAL_CLUSTER_PORT;
        }
        return this.getClusterConfig().cluster.port;
    }
    getClusterServiceHost() {
        if (process?.env?.KAPETA_LOCAL_CLUSTER_HOST) {
            return process.env.KAPETA_LOCAL_CLUSTER_HOST;
        }
        return this.getClusterConfig().cluster.host;
    }
    /**
     * User configured docker connection information
     */
    getDockerConfig() {
        return this.getClusterConfig().docker;
    }
    getRemoteServices() {
        let remoteServices = this.getClusterConfig().remoteServices;
        if (!remoteServices) {
            remoteServices = {};
            this.getClusterConfig().remoteServices = remoteServices;
        }
        return this.getClusterConfig().remoteServices;
    }
    getRemoteService(name, defaultValue) {
        return this.getRemoteServices()[name] ?? defaultValue;
    }
    getKapetaBasedir() {
        return KAPETA_DIR;
    }
    getAuthenticationPath() {
        return AUTH_TOKEN_PATH;
    }
    /**
     * Gets the base directory of a provider
     * @return {string}
     */
    getRepositoryBasedir() {
        return REPOSITORY_DIR;
    }
    getRepositoryAssetPath(handle, name, version) {
        return path_1.default.join(this.getRepositoryBasedir(), handle, name, version);
    }
    getRepositoryAssetInfoPath(handle, name, version) {
        const assetBase = this.getRepositoryAssetPath(handle, name, version);
        const kapetaBase = path_1.default.join(assetBase, '.kapeta');
        return {
            baseDir: kapetaBase,
            assetFile: path_1.default.join(assetBase, 'kapeta.yml'),
            versionFile: path_1.default.join(kapetaBase, 'version.yml'),
        };
    }
    /**
     * Gets an array of all provider definitions along with their paths
     *
     * @param [kindFilter] {string|string[]} if provided will only return definitions of this kind
     * @return {{ymlPath:string,path:string,version:string,hasWeb:boolean,definition:{}}[]}
     */
    getProviderDefinitions(kindFilter) {
        let resolvedFilters = [];
        if (!kindFilter) {
            resolvedFilters = [...PROVIDER_TYPES];
        }
        else {
            resolvedFilters = Array.isArray(kindFilter) ? [...kindFilter] : [kindFilter];
        }
        return this.getDefinitions(resolvedFilters);
    }
    /**
     * Gets an array of all definitions along with their paths from the local repository
     */
    getDefinitions(kindFilter) {
        if (!fs_1.default.existsSync(this.getRepositoryBasedir())) {
            return [];
        }
        let resolvedFilters = [];
        if (kindFilter) {
            if (Array.isArray(kindFilter)) {
                resolvedFilters = [...kindFilter];
            }
            else {
                resolvedFilters = [kindFilter];
            }
        }
        resolvedFilters = resolvedFilters.map((k) => k.toLowerCase());
        const ymlFiles = glob_1.default.sync('*/*/*/@(kapeta.yml)', {
            cwd: this.getRepositoryBasedir(),
            ignore: 'node_modules/**',
        });
        const lists = ymlFiles
            .map((folder) => path_1.default.join(this.getRepositoryBasedir(), folder))
            .map((ymlPath) => {
            return {
                path: path_1.default.dirname(ymlPath),
                ymlPath,
            };
        })
            .map((obj) => {
            if (!fs_1.default.existsSync(obj.ymlPath)) {
                return [];
            }
            const raw = fs_1.default.readFileSync(obj.ymlPath).toString();
            let version = 'local';
            const versionInfoFile = path_1.default.join(obj.path, '.kapeta', 'version.yml');
            if (fs_1.default.existsSync(versionInfoFile)) {
                try {
                    const versionInfo = yaml_1.default.parse(fs_1.default.readFileSync(versionInfoFile).toString());
                    if (!versionInfo?.version) {
                        console.warn(`Invalid version file ${versionInfoFile}`);
                        return [];
                    }
                    version = versionInfo.version;
                }
                catch (e) {
                    console.warn(`Invalid version file ${versionInfoFile}`, e);
                    return [];
                }
            }
            return yaml_1.default.parseAllDocuments(raw)
                .map((doc) => doc.toJSON())
                .map((data) => {
                return {
                    ymlPath: obj.ymlPath,
                    path: obj.path,
                    version,
                    definition: data,
                    hasWeb: fs_1.default.existsSync(path_1.default.join(obj.path, 'web')),
                };
            });
        });
        let definitions = [];
        lists.forEach((list) => {
            definitions = definitions.concat(list);
        });
        return definitions.filter((out) => {
            if (resolvedFilters && resolvedFilters.length > 0) {
                return out.definition.kind && resolvedFilters.indexOf(out.definition.kind.toLowerCase()) > -1;
            }
            return !!out.definition.kind;
        });
    }
    getClusterConfigFile() {
        return CLUSTER_CONFIG_FILE;
    }
    getClusterConfig() {
        if (this._clusterConfig != null) {
            return this._clusterConfig;
        }
        if (fs_1.default.existsSync(CLUSTER_CONFIG_FILE)) {
            const rawYAML = fs_1.default.readFileSync(CLUSTER_CONFIG_FILE).toString();
            this._clusterConfig = yaml_1.default.parse(rawYAML);
        }
        if (!this._clusterConfig) {
            this._clusterConfig = {};
        }
        if (!this._clusterConfig.cluster) {
            this._clusterConfig.cluster = {};
        }
        if (!this._clusterConfig.cluster.port) {
            this._clusterConfig.cluster.port = KAPETA_CLUSTER_SERVICE_DEFAULT_PORT;
        }
        if (!this._clusterConfig.cluster.host) {
            this._clusterConfig.cluster.host = KAPETA_CLUSTER_SERVICE_DEFAULT_HOST;
        }
        if (!this._clusterConfig.docker) {
            this._clusterConfig.docker = {};
        }
        console.log('Read cluster config from file: %s', CLUSTER_CONFIG_FILE);
        return this._clusterConfig;
    }
    getClusterServiceAddress() {
        const clusterPort = this.getClusterServicePort();
        const host = this.getClusterServiceHost();
        return `http://${host}:${clusterPort}`;
    }
}
exports.ClusterConfiguration = ClusterConfiguration;
