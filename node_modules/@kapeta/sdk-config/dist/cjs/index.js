"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const yaml_1 = __importDefault(require("yaml"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const KubernetesConfigProvider_1 = require("./src/providers/KubernetesConfigProvider");
const LocalConfigProvider_1 = require("./src/providers/LocalConfigProvider");
const KAPETA_SYSTEM_TYPE = 'KAPETA_SYSTEM_TYPE';
const KAPETA_SYSTEM_ID = 'KAPETA_SYSTEM_ID';
const KAPETA_BLOCK_REF = 'KAPETA_BLOCK_REF';
const KAPETA_INSTANCE_ID = 'KAPETA_INSTANCE_ID';
const DEFAULT_SYSTEM_TYPE = 'development';
const DEFAULT_SYSTEM_ID = '';
const DEFAULT_INSTANCE_ID = '';
if (!('KAPETA_SDK_NODEJS_CONFIG' in global)) {
    //We want these values to be truly global within the VM
    // @ts-ignore
    global['KAPETA_SDK_NODEJS_CONFIG'] = {
        PROVIDER: null,
        CALLBACKS: [],
    };
}
// @ts-ignore
const CONFIG = global['KAPETA_SDK_NODEJS_CONFIG'];
function getSystemConfiguration(envVarName, defaultValue) {
    if (process.env[envVarName]) {
        return process.env[envVarName];
    }
    return defaultValue;
}
class Config {
    /**
     * Provide callback for when configuration is ready.
     *
     */
    static onReady(callback) {
        if (CONFIG.PROVIDER) {
            callback(CONFIG.PROVIDER);
            return;
        }
        CONFIG.CALLBACKS.push(callback);
    }
    static isReady() {
        return !!CONFIG.PROVIDER;
    }
    /**
     * Get provider - if not ready, will throw an error
     */
    static getProvider() {
        if (!CONFIG.PROVIDER) {
            throw new Error('Configuration not yet initialised');
        }
        return CONFIG.PROVIDER;
    }
    /**
     * Get configuration value
     */
    static get(path, defaultValue) {
        return Config.getProvider().getConfiguration(path, defaultValue);
    }
    static async getAsInstanceHost(path, defaultValue) {
        /**
         *
         * @type {InstanceValue}
         */
        const instance = Config.get(path);
        if (!instance) {
            return defaultValue ?? null;
        }
        return Config.getInstanceHost(instance.id);
    }
    /**
     * Get hostname and port for instance
     */
    static getInstanceHost(instanceId) {
        return Config.getProvider().getInstanceHost(instanceId);
    }
    /**
     * Inits and loads config provider
     */
    static async init(blockDir, healthEndpoint, portType = 'rest') {
        if (CONFIG.PROVIDER) {
            throw new Error('Configuration already initialised once');
        }
        let blockYMLPath = path_1.default.join(blockDir, 'kapeta.yml');
        if (!fs_1.default.existsSync(blockYMLPath)) {
            throw new Error('kapeta.yml file not found in path: ' +
                blockDir +
                '. Path must be absolute and point to a folder with a valid block definition.');
        }
        const blockDefinition = yaml_1.default.parse(fs_1.default.readFileSync(blockYMLPath).toString());
        if (!blockDefinition?.metadata?.name) {
            throw new Error('kapeta.yml file contained invalid YML: ' + blockDir + '. ');
        }
        const blockRefLocal = `${blockDefinition?.metadata?.name}:local`;
        const systemType = getSystemConfiguration(KAPETA_SYSTEM_TYPE, DEFAULT_SYSTEM_TYPE).toLowerCase();
        const blockRef = getSystemConfiguration(KAPETA_BLOCK_REF, blockRefLocal);
        const systemId = getSystemConfiguration(KAPETA_SYSTEM_ID, DEFAULT_SYSTEM_ID);
        const instanceId = getSystemConfiguration(KAPETA_INSTANCE_ID, DEFAULT_INSTANCE_ID);
        /**
         *
         * @type {ConfigProvider}
         */
        let provider = null;
        switch (systemType) {
            case 'k8s':
            case 'kubernetes':
                provider = await KubernetesConfigProvider_1.KubernetesConfigProvider.create(blockRef, systemId, instanceId, blockDefinition);
                break;
            case 'development':
            case 'dev':
            case 'local':
                const localProvider = await LocalConfigProvider_1.LocalConfigProvider.create(blockRef, systemId, instanceId, blockDefinition);
                //Only relevant locally:
                await localProvider.registerInstance(healthEndpoint, portType);
                provider = localProvider;
                break;
            default:
                throw new Error('Unknown environment: ' + systemType);
        }
        CONFIG.PROVIDER = provider;
        while (CONFIG.CALLBACKS.length > 0) {
            const callback = CONFIG.CALLBACKS.shift();
            await callback(CONFIG.PROVIDER);
        }
        return provider;
    }
}
__exportStar(require("./src/types"), exports);
__exportStar(require("./src/providers/AbstractConfigProvider"), exports);
__exportStar(require("./src/providers/LocalConfigProvider"), exports);
__exportStar(require("./src/providers/KubernetesConfigProvider"), exports);
exports.default = Config;
